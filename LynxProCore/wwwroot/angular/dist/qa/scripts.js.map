{"version":3,"file":"scripts.js","mappings":"CAAA,cAKAA,mBACA,OAAmBC,sBAEnB,mBACA,SACAC,uBACAA,kCACAA,WACAC,6BACAC,iCACAC,oCAEA,UACA,SACAH,oCACA,UACA,YACAA,kCACAA,WACAC,6BACAC,iCACAC,oCAEA,UACA,WACAH,kCACA,UACA,UACAA,mCACAA,WACAC,6BACAC,iCACAC,oCAKA,UAMAL,oBAEA,WAEA,mBACA,UACAE,0BAA8CI,kEAC9CC,qCACAL,2CACAA,6CACA,UACA,SAEAA,OADA,kCACA,qBACAM,yCACAC,YACAC,4BACAC,0BACAC,wBACAC,wBACAC,8BAIA,wBAAkDN,uDAElD,UACA,aACAN,6BAAiDa,0CACjDR,qCACAL,2CACAA,6CACA,UACA,WACAA,4BAAgDc,4BAChD,UACA,WACAd,2BAA+Ce,8BAC/CV,qCACAL,2CACAA,6CAIA,oCACA,OACAA,aAA2BgB,QAG3BhB,GAGAF,mBAEA,GADAmB,4BACAC,EACA,mDAGA,QADAlB,KACAmB,IAA0BA,aAAiBA,EAC3CnB,sBAEA,UAIAF,kBACA,sBACA,mDAIA,QADAoB,KACAlB,IAA0BA,aAAiBA,EAC3CkB,kCAEA,UAIApB,mBACA,SACAmB,4BACA,YAAsBE,aAAkBA,EACxCnB,wBAEA,UAGAF,kBAEA,QADAoB,KACAlB,IAAsBA,aAAkBA,EACxCkB,iCAEA,UAGApB,iBACA,yBAGAA,oBACA,oCAGAA,iBACA,iCACAsB,4BAGAtB,oBACA,2DACAsB,yBAGAtB,iBAEA,QADAoB,uDACAlB,IAAsBA,aAAcA,EACpC,6CACA,aAKAF,kBACA,2CA3KA,CA8KCuB","names":["r","type","o","fillColor","strokeColor","strokeWeight","radius","set","position","icon","labelContent","labelAnchor","labelClass","labelStyle","labelVisible","bounds","path","paths","map","t","e","l","this","window"],"sourceRoot":"webpack:///","sources":["src\\app\\shared\\custom-js\\overlayIO.js"],"sourcesContent":["(function (overlayIO, undefined) {\r\n\r\n  // shape: google.maps.Overlay\r\n  // encoded: boolean indicating whether pathes should be stored encoded\r\n  // Returns storable google.maps.Overlay-definition\r\n  overlayIO.in = function (shape, encoded) {\r\n      var temp = { type: this.t_(shape.type) };\r\n\r\n      switch (temp.type) {\r\n          case 'CIRCLE':\r\n              temp.radius = shape.getRadius();\r\n              temp.geometry = this.p_(shape.getCenter());\r\n              temp.options = {\r\n                  fillColor: shape.get('fillColor'),\r\n                  strokeColor: shape.get('strokeColor'),\r\n                  strokeWeight: shape.get('strokeWeight')\r\n              };\r\n              break;\r\n          case 'MARKER':\r\n              temp.geometry = this.p_(shape.getPosition());\r\n              break;\r\n          case 'RECTANGLE':\r\n              temp.geometry = this.b_(shape.getBounds());\r\n              temp.options = {\r\n                  fillColor: shape.get('fillColor'),\r\n                  strokeColor: shape.get('strokeColor'),\r\n                  strokeWeight: shape.get('strokeWeight')\r\n              };\r\n              break;\r\n          case 'POLYLINE':\r\n              temp.geometry = this.l_(shape.getPath(), encoded);\r\n              break;\r\n          case 'POLYGON':\r\n              temp.geometry = this.m_(shape.getPaths(), encoded);\r\n              temp.options = {\r\n                  fillColor: shape.get('fillColor'),\r\n                  strokeColor: shape.get('strokeColor'),\r\n                  strokeWeight: shape.get('strokeWeight')\r\n              };\r\n              break;\r\n      }\r\n\r\n      return temp;\r\n  }\r\n\r\n  // shape: google.maps.Overlay\r\n  // map: map where to draw the shapes\r\n  // Returns google.maps.Overlay\r\n  overlayIO.out = function (shape, map) {\r\n\r\n      var temp = null;\r\n\r\n      switch (shape.type) {\r\n          case 'CIRCLE':\r\n              temp = new google.maps.Circle({ radius: Number(shape.radius), center: this.pp_.apply(this, shape.geometry) });\r\n              temp.set('fillColor', shape.options.fillColor);\r\n              temp.set('strokeColor', shape.options.strokeColor);\r\n              temp.set('strokeWeight', shape.options.strokeWeight);\r\n              break;\r\n          case 'MARKER':\r\n              if (typeof shape.withLabel !== 'undefined' && shape.withLabel === true) {\r\n                  temp = new MarkerWithLabel({\r\n                      position: this.pp_.apply(this, shape.geometry),\r\n                      icon: shape.icon,\r\n                      labelContent: shape.labelContent,\r\n                      labelAnchor: shape.labelAnchor,\r\n                      labelClass: shape.labelClass,\r\n                      labelStyle: shape.labelStyle,\r\n                      labelVisible: shape.labelVisible\r\n                  });\r\n              }\r\n              else {\r\n                  temp = new google.maps.Marker({ position: this.pp_.apply(this, shape.geometry), icon: shape.icon });\r\n              }\r\n              break;\r\n          case 'RECTANGLE':\r\n              temp = new google.maps.Rectangle({ bounds: this.bb_.apply(this, shape.geometry) });\r\n              temp.set('fillColor', shape.options.fillColor);\r\n              temp.set('strokeColor', shape.options.strokeColor);\r\n              temp.set('strokeWeight', shape.options.strokeWeight);\r\n              break;\r\n          case 'POLYLINE':\r\n              temp = new google.maps.Polyline({ path: this.ll_(shape.geometry) });\r\n              break;\r\n          case 'POLYGON':\r\n              temp = new google.maps.Polygon({ paths: this.mm_(shape.geometry) });\r\n              temp.set('fillColor', shape.options.fillColor);\r\n              temp.set('strokeColor', shape.options.strokeColor);\r\n              temp.set('strokeWeight', shape.options.strokeWeight);\r\n              break;\r\n      }\r\n\r\n      temp.type = this.tt_(shape.type);\r\n      if (typeof map !== 'undefined') {\r\n          temp.setValues({ map: map })\r\n      }\r\n\r\n      return temp;\r\n  }\r\n\r\n  overlayIO.l_ = function (path, e) {\r\n      path = (path.getArray) ? path.getArray() : path;\r\n      if (e) {\r\n          return google.maps.geometry.encoding.encodePath(path);\r\n      } else {\r\n          var r = [];\r\n          for (var i = 0; i < path.length; ++i) {\r\n              r.push(this.p_(path[i]));\r\n          }\r\n          return r;\r\n      }\r\n  }\r\n\r\n  overlayIO.ll_ = function (path) {\r\n      if (typeof path === 'string') {\r\n          return google.maps.geometry.encoding.decodePath(path);\r\n      }\r\n      else {\r\n          var r = [];\r\n          for (var i = 0; i < path.length; ++i) {\r\n              r.push(this.pp_.apply(this, path[i]));\r\n          }\r\n          return r;\r\n      }\r\n  }\r\n\r\n  overlayIO.m_ = function (paths, e) {\r\n      var r = [];\r\n      paths = (paths.getArray) ? paths.getArray() : paths;\r\n      for (var i = 0; i < paths.length; ++i) {\r\n          r.push(this.l_(paths[i], e));\r\n      }\r\n      return r;\r\n  }\r\n\r\n  overlayIO.mm_ = function (paths) {\r\n      var r = [];\r\n      for (var i = 0; i < paths.length; ++i) {\r\n          r.push(this.ll_.call(this, paths[i]));\r\n      }\r\n      return r;\r\n  }\r\n\r\n  overlayIO.p_ = function (latLng) {\r\n      return ([latLng.lat(), latLng.lng()]);\r\n  }\r\n\r\n  overlayIO.pp_ = function (lat, lng) {\r\n      return new google.maps.LatLng(lat, lng);\r\n  }\r\n\r\n  overlayIO.b_ = function (bounds) {\r\n      return ([this.p_(bounds.getSouthWest()),\r\n              this.p_(bounds.getNorthEast())]);\r\n  }\r\n\r\n  overlayIO.bb_ = function (sw, ne) {\r\n      return new google.maps.LatLngBounds(this.pp_.apply(this, sw),\r\n                                          this.pp_.apply(this, ne));\r\n  }\r\n\r\n  overlayIO.t_ = function (s) {\r\n      var t = ['CIRCLE', 'MARKER', 'RECTANGLE', 'POLYLINE', 'POLYGON'];\r\n      for (var i = 0; i < t.length; ++i) {\r\n          if (s === google.maps.drawing.OverlayType[t[i]]) {\r\n              return t[i];\r\n          }\r\n      }\r\n  }\r\n\r\n  overlayIO.tt_ = function (t) {\r\n      return google.maps.drawing.OverlayType[t];\r\n  }\r\n\r\n}(window.overlayIO = window.overlayIO || {}));\r\n"]}